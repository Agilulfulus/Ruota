load "System";
load "Map";
load "Arrays";

dynamic Huffman :: {
	head := null;
	dict := null;
	undict := null;
	encoded := "";

	dynamic Node :: {
		a := null;
		b := null;
		parent := null;
		weight := null;
		value := null;

		getDict(c) => dict from {
			dict = new Map;
			value == null then {
				adict := a.getDict(c .. "1");
				bdict := b.getDict(c .. "0");
				dict.contents = dict.contents ++ adict.contents ++ bdict.contents;
			} else {
				dict[value] = c;
			};
		};

		init(value, weight) => {
			self.value = value;
			self.weight = weight;
		};

		string() => s from {
			s = "(W=" .. weight;
			value == null then {
				s = s .. ", " .. a .. ", " .. b .. ")";
			} else {
				s = s .. ", " .. value .. ")";
			};
		};
	};

	init(text) => {
		char_table := new Map;
		c in text do {
			!char_table.containsKey(c) then {
				char_table[c] = 0;
			};
			char_table[c] = char_table[c] + 1;
		};
		nodes := [];
		e in char_table do {
			nodes push new Node(e.key, e.value);
		};
		len nodes > 1 do {
			nodes = Arrays.sort(nodes, ((a, b) -> { a.weight > b.weight }));
			b := end nodes;
			pop nodes;
			a := end nodes;
			pop nodes;
			c := new Node(null, a.weight + b.weight);
			c.a = a;
			c.b = b;
			a.parent = c;
			b.parent = c;
			nodes push c;
		};

		head = nodes[1];
		dict = head.getDict("");
		undict = dict.invert();

		encoded = alloc(len text * 127);
		i := 0;
		c in text do {
			val := dict[c];
			c2 in val do {
				i = i + 1;
				encoded[i] = c2;
			};
		};
		encoded = str encoded[1:i];
	};

	decode() => decoded from {
		decoded := alloc(len encoded);
		curr := "";
		i := 0;
		c in encoded do {
			curr = curr .. c;
			undict.containsKey(curr) then {
				i = i + 1;
				decoded[i] = undict[curr];
				curr = "";
			};
		};
		decoded = str decoded[1:i];
	};

	toArray() => array from {
		array = [1 : len encoded];
		i in [1 : len encoded] do {
			array[i] = index(i);
		};
	};
	
	index(pos) => { num str encoded[pos] };
	string() => { encoded };
	size() => { len encoded };
};